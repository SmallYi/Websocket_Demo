import loggingimport threadingimport tracebackimport sysfrom concurrent.futures import ThreadPoolExecutorfrom tornado.concurrent import run_on_executor_time = 0count = 0_max = -99999999_min = 9999999time_lock = threading.Lock()def averagetime(newtime):    global _time,count,_max,_min    time_lock.acquire()    _max = max(newtime,_max)    _min = min(newtime,_min)    _time = (_time*count + newtime)/(count +1)    count +=1    print("%f"%_time, count,_max,_min)    time_lock.release()# logging.basicConfig(level=logging.DEBUG,#                 format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',#                 datefmt='%a, %d %b %Y %H:%M:%S',#                 filename='/Users/ksht/logs/hufen.log',#                 filemode='w')DEBUG = Trueprint_ = printdef pr(*args,**kwargs):    if DEBUG:        print_(*args,**kwargs)    else:        logging.debug(args,**kwargs)print = primport osimport sys# Time:2017-12-18 Author:JiangShuaisys.path.append("/home/ksht/") #windows环境不用管 linux是应用的路径os.environ['DJANGO_SETTINGS_MODULE'] = 'ksht.settings'  # 项目的settingsfrom django.core.wsgi import get_wsgi_applicationapplication = get_wsgi_application()from django.utils import timezone # 带时区的时间from django.contrib.sessions.models import Sessionfrom django.db.models import Ffrom ksuser.models import Userfrom hufen.models import HufenHistory,UserHeadProfile#上面过程是引用Django的ORM模型import timeimport tornado.webimport tornado.websocketimport tornado.httpserverimport tornado.ioloopimport threadingimport jsonimport requestsimport base64from ksht import settingsurl = "http://gifshow.3agzs.com/rest/n/user/profile/v2"cost = settings.cost#互粉成功扣除积分PairTime = settings.PairTime# 匹配时间WaitTime = settings.WaitTime# 互粉等待时间LiveCheckTime = settings.LiveCheckTime# 匹配成功判断对方是否在线addweight = settings.addweight# 每次增加的权重值users = dict()  # 所有登陆用户信息 {userid:self}users_lock = threading.Lock()pairs = dict()  # 待配对用户信息 {userid:[self,weight,beweight]} 匹配权重 被匹配权重pairs_lock = threading.Lock()alive = dict() # 判断匹配双方是否都在线 {key,[self1,self2]}alive_lock = threading.Lock()pairing = dict()  # 正在匹配的成对用户信息，{key,[self1,self2,step]}pairing_lock = threading.Lock()checktime = dict() # 正在判断超时的用户 {userid:[self,Sta,PrePos/PreStep]} [状态，上一步状态]checktime_lock = threading.Lock()hufenstate = dict() # 保存用户状态 {userid:{HufenPos,PairUserId,PairingPos,IsWait,IsDU,StaTime,OverTime,Pairtotaltime,Pairsucrate,Weight,PairWeight}}success = 0suc_lock = threading.Lock()def session2user(sessionid):    sessionobj = Session.objects.get(session_key=sessionid)    userobj = User.objects.get(id=sessionobj.get_decoded()["_auth_user_id"])    return userobj# 状态1 2 3的互粉列表更新def HufenFail123(self,sta,info):    uptime = timezone.now()    self.user = User.objects.filter(userid=self.userid).first()    self.pairuser = User.objects.filter(userid=self.pairuserid).first()    if self.userid < self.pairuserid:        first = self.user        second = self.pairuser    else:        first = self.pairuser        second = self.user    ID = str(first.userid) + '_' + str(second.userid)    if sta == 3:        HufenHistory.objects.filter(HufenId=ID) \            .update(user1=first,user2=second,state=sta,errinfo=info,hftime=uptime)    else:        HufenHistory.objects.filter(HufenId=ID) \            .update(user1=first, user2=second,state=sta,hftime=uptime)# 状态0 4 5的互粉列表更新def HufenFail045(self,sta,bgu):    uptime = timezone.now()    self.user = User.objects.filter(userid=self.userid).first()    self.pairuser = User.objects.filter(userid=self.pairuserid).first()    if self.userid < self.pairuserid:        first = self.user        second = self.pairuser    else:        first = self.pairuser        second = self.user    ID = str(first.userid) + '_' + str(second.userid)    HufenHistory.objects.filter(HufenId=ID) \        .update(user1=first, user2=second,state=sta,bguser=bgu,hftime=uptime)# 获取会话键值def get_key(self):    first = self.userid    second = self.pairuserid    if self.userid > self.pairuserid:  # first 代表编号小的用户Id        first = self.pairuserid        second = self.userid    key = str(first) + '_' + str(second)    return key# 系统异常def ServerError(self,info):    self.HufenPos = 0    StateSave(self,0,0)    message = json.dumps({"error": "server","otherid":self.pairuserid})    WriteMessage(self,message)    if info == "会话异常":        key = get_key(self)        print("会话异常：" + str(len(pairing[key])))    print(info)    HufenFail123(self,3,info)# 互粉一方终止时提醒对方，只有双方都终止互粉才删除会话def TipForError(self,key,message):    global checktime    self.HufenPos = 0    StateSave(self, 0, 0)    DelPairing(key)    HufenFail045(self,4,self.user)    if self.pairuserid in users:        users[self.pairuserid].HufenPos = 0        StateSave(users[self.pairuserid], 0, 0)        WriteMessage(users[self.pairuserid],message)        # 取消计时        if self.pairuserid in checktime:            checktime[self.pairuserid][0].timewait = 0    else:        print("用户：" + self.user.username + "不在用户表中")# 换个老铁提醒def TipForChange(self):    global checktime    key = get_key(self)    if key in pairing:        DelPairing(key)    HufenFail045(self, 4, self.user)    # 告知与该用户匹配的用户：互粉结束    message = json.dumps({        "action": "errorpair",        "state": "change"})    # 判断目标用户是否还存在    if self.pairuserid in users:        # 重置对方的状态        users[self.pairuserid].HufenPos = 0        StateSave(users[self.pairuserid], 0, 0)        WriteMessage(users[self.pairuserid], message)        if self.pairuserid in checktime:            checktime[self.pairuserid][0].timewait = 0    DoPair(self, timezone.now(), PairTime)# 计算互粉总次数与互粉率def HufenRate(self):    # 匹配总次数    self.totaltime = HufenHistory.objects.filter(user1=self.user).count() + \                     HufenHistory.objects.filter(user2=self.user).count()    # 互粉成功次数    suctime = len(HufenHistory.objects.filter(user1=self.user, state=1)) + \              len(HufenHistory.objects.filter(user2=self.user, state=1))    if self.totaltime:        self.sucrate = str(float("%.2f" %(suctime / self.totaltime))) + "%"    else:        self.sucrate = "0.00%"# 状态保存def StateSave(self,Pos,flag):    global hufenstate    # 互粉中    if flag:        state = {                'HufenPos': self.HufenPos,                'PairUserId': self.pairuserid,                'PairingPos': Pos,                'IsWait': 0,                'IsDU': self.IsDU,                'StaTime': timezone.now(),                'OverTime': 0,                'Pairtotaltime':0,                'Pairsucrate':0.0,                'Weight':self.weight,                'PairWeight':self.pairweight,                'Beweight':self.bepairweight        }        hufenstate[self.userid] = state    # 无操作或匹配中    else:        state = {            'HufenPos': self.HufenPos,            'PairUserId': self.pairuserid,            'PairingPos': 0,            'IsWait': 0,            'IsDU': 0,            'StaTime': timezone.now(),            'OverTime': 0,            'Pairtotaltime': 0,            'Pairsucrate': 0.0,            'Weight': self.weight,            'PairWeight': self.pairweight,            'Beweight': self.bepairweight        }        hufenstate[self.userid] = state# 重新匹配def DoPair(self,statime,overtime):    global pairs    global pairs_weight    global pairs_beweight    global pairs_lock    global cost    if User.objects.filter(userid=self.userid, integral__gte=F('integral') - cost):        GetProfile(self)        SaveProfile(self)        # 计算互粉总次数与互粉率        HufenRate(self)        self.HufenPos = 1  # 进入匹配状态        self.pairwait = 1        self.user = User.objects.filter(userid=self.userid).first()        weight = settings.setweight(self.user, self.addcredit, self.totaltime, self.sucrate)        self.weight = weight        pairs_lock.acquire()        pairs[self.userid] = [self, weight, self.bepairweight]  # 将该用户添加进待匹配字典中        pairs_lock.release()        self.statime = statime        self.overtime = overtime        SetCheckTime(self, 1, 1)  # 进入超时判断队列        # 保存匹配状态        StateSave(self, 0, 0)        hufenstate[self.userid]['IsWait'] = 1        hufenstate[self.userid]['StaTime'] = self.statime        hufenstate[self.userid]['OverTime'] = self.overtime        # print(self.user.username ,"开始匹配,匹配权值、被匹配权值",self.weight,self.bepairweight)    else:        message = json.dumps({"action": "needcost", "cost": cost})        WriteMessage(self, message)# 状态恢复，重新计时def ReCheckTime(self,statime,overtime,pos,option):    self.statime = statime    self.overtime = overtime    SetCheckTime(self,2,pos) # 进入超时判断队列    # 正在确认    if option == 0:        message = json.dumps({"action": "rechecktime","state": "makeconfirm"})    # 等待对方关注您    elif option == 1:        message = json.dumps({"action": "rechecktime", "state": "waitcheck"})    # 确认已关注    elif option == 2:        message = json.dumps({"action": "rechecktime", "state": "makefocus"})    # 正在关注    elif option == 3:        message = json.dumps({"action": "rechecktime", "state": "dofocus"})    # 等待确认    elif option == 4:        message = json.dumps({"action": "rechecktime", "state": "waitpair"})    # 等待最终确认    elif option == 5:        message = json.dumps({"action": "rechecktime", "state": "waitfin"})    WriteMessage(self, message)    # 状态恢复，重新提醒错误def ReTipForError(self,message):    global checktime    self.HufenPos = 0    StateSave(self, 0, 0)    WriteMessage(self, message)    # 取消计时    if self.userid in checktime:        checktime[self.userid][0].timewait = 0# 状态恢复，对方等待超时def TipForOvertime(self):    self.HufenPos = 0    StateSave(self, 0, 0)    workovertime = json.dumps({"action": "errorpair", "state": "workovertime","otherid":self.pairuserid})    WriteMessage(self,workovertime)def SetCheckTime(self,Sta,Pos):    global checktime    global checktime_lock    self.timewait = 1    checktime_lock.acquire()    checktime[self.userid] = [self, Sta, Pos]    checktime_lock.release()# 判断用户是否存在def CheckUserlist(uid):    userlist = list(users.keys())    for user in userlist:        if uid == user:            print(str(uid) + "已登录")            if user in users:                message = json.dumps({"action": "close"})                WriteMessage(users[user],message)                DelUser(user)            else:                print(str(uid) + "不在用户列表中")# 冒泡排序 降序def bubble_sort(dic,flag):    lis = list(dic.values())    ret = list(dic.keys())    count = len(lis)    if flag:        for i in range(0, count):            for j in range(i + 1, count):                if lis[i][1] < lis[j][1]:                    ret[i], ret[j] = ret[j], ret[i]    else:        for i in range(0, count):            for j in range(i + 1, count):                if lis[i][2] < lis[j][2]:                    ret[i], ret[j] = ret[j], ret[i]    return ret# 删除用户时上锁def DelUser(userid):    global users    global users_lock    try:        users[userid].close()    except Exception as e:        print(e)        print(userid,"close_error")    finally:        users[userid].state_alive = False# 删除互粉会话时上锁def DelPairing(key):    global pairing    global alive    global pairing_lock    pairing_lock.acquire()    del pairing[key]    if key in alive:        alive_lock.acquire()        del alive[key]        alive_lock.release()    pairing_lock.release()# 服务器发消息时判断连接是否已断开def WriteMessage(self,message):    global Msg_lock    if self.state_alive:        try:            self.write_message(message)        except Exception as e:            info = sys.exc_info()            for file, lineno, function, text in traceback.extract_tb(info[2]):                print("write",file, "line:", lineno, "in", function)                print("write",text)            print("write","** %s: %s" % info[:2])        # finally:        #     Msg_lock.release()    else:        print(self.userid,"句柄已经更新")def GetProfile(self):    global url    try:        r = requests.get(url,{"user":self.user.userid})        data = r.json()        self.username = data["userProfile"]["profile"]["user_name"]        self.headurl = data["userProfile"]["profile"]["headurl"]        print(self.username,self.headurl)    except:        self.username = None        self.headurl = None        print("getprofile_error")def SaveProfile(self):    if self.username:        name = base64.b64encode(self.username.encode('utf-8'))        print(str(name,'utf-8'))        if UserHeadProfile.objects.filter(user=self.user).first():            UserHeadProfile.objects.filter(user=self.user).update(name=str(name,'utf-8'),headurl=self.headurl)        else:            UserHeadProfile.objects.create(user=self.user,name=str(name,'utf-8'),headurl=self.headurl)    else:        print("saveprofile_error")# 处理状态恢复的类class StateBack():    global pairs    global alive    global alive_lock    global PairTime    global pairing    global cost    def PairStateBack(self,handle):        handle.HufenPos = 0        handle.pairuserid = handle.userid        StateSave(handle, 0, 0)        # 不在匹配队列中 清除alive缓冲区        if handle.userid not in pairs:            key = get_key(handle)            if key in alive:                if len(alive[key]) == 0:                    alive_lock.acquire()                    del alive[key]                    alive_lock.release()                elif len(alive[key]) == 1:                    alive[key][0].addcredit = alive[key][0].addcredit + addweight                    DoPair(alive[key][0], timezone.now(), PairTime)                    alive_lock.acquire()                    del alive[key]                    alive_lock.release()    # 掉线之后对方才点击确认互粉    def HufenStateBack_1(self,handle,pairuser,UserState):        message = json.dumps({            "action": "pair",            "username": pairuser.username,            "userid": handle.pairuserid,            "photo": pairuser.total_photo,            "credit": pairuser.credit,            "totaltime": UserState['Pairtotaltime'],            "sucrate": UserState['Pairsucrate']})        WriteMessage(handle, message)    # 自身处于等待，即自身先点击了确定互粉，继续等待    def HufenStateBack_2(self,handle,key,UserState):        global pairing        global WaitTime        # 更新会话        if len(pairing[key]) == 1:            pairing[key] = [handle]            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], -1, 4)        # 对方点击了确定互粉        elif len(pairing[key]) == 3:            # 对方是DU            if UserState['IsDU'] == 0:                pairing[key][1] = handle                if pairing[key][2] == 0:                    ReCheckTime(handle, timezone.now(), WaitTime, 0, 1)                elif pairing[key][2] == 1:                    ReCheckTime(handle, timezone.now(), WaitTime, 1, 3)                elif pairing[key][2] == 2:                    message = json.dumps({                        "action": "checkfocusfirst",                        "userid": handle.userid})                    WriteMessage(handle, message)            # 自身是DU            elif UserState['IsDU'] == 1:                pairing[key][0] = handle                message = json.dumps({                    "action": "dopairfirst",                    "userid": handle.pairuserid})                WriteMessage(handle, message)    # 对方处于等待，重新发送匹配消息    def HufenStateBack_3(self, handle, pairuser, UserState):        message = json.dumps({            "action": "pair",            "username": pairuser.username,            "userid": handle.pairuserid,            "photo": pairuser.total_photo,            "credit": pairuser.credit,            "totaltime": UserState['Pairtotaltime'],            "sucrate": UserState['Pairsucrate']})        WriteMessage(handle, message)    # 自身是GU，DU还未选择关注    def HufenStateBack_4(self,handle,key,UserState):        # 更新会话中的GU句柄        pairing[key][1] = handle        if pairing[key][2] == 0:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 0, 1)        elif pairing[key][2] == 1:            ReCheckTime(handle, timezone.now(), WaitTime, 1, 3)        elif pairing[key][2] == 2:            message = json.dumps({                "action": "checkfocusfirst",                "userid": handle.userid})            WriteMessage(handle, message)    # 自身是DU 先关注    def HufenStateBack_5(self,handle,key):        # 更新会话中DU的句柄        pairing[key][0] = handle        message = json.dumps({            "action": "dopairfirst",            "userid": handle.pairuserid})        WriteMessage(handle, message)    # 自身是GU 继续等待    def HufenStateBack_6(self,handle,key,UserState):        pairing[key][1] = handle        if pairing[key][2] == 1:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 1, 3)        elif pairing[key][2] == 2:            message = json.dumps({                "action": "checkfocusfirst",                "userid": handle.userid})            WriteMessage(handle, message)    # 自身是DU 确认是否已关注GU    def HufenStateBack_7(self,handle,key):        pairing[key][0] = handle        message = json.dumps({"action": "doconfirmfirst"})        WriteMessage(handle, message)    # 自身是DU，等待GU去快手确认    def HufenStateBack_8(self,handle,key,UserState):        pairing[key][0] = handle        if pairing[key][2] == 2:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 2, 1)        elif pairing[key][2] == 3:            ReCheckTime(handle, timezone.now(), WaitTime, 3, 0)        elif pairing[key][2] == 4:            ReCheckTime(handle, timezone.now(), WaitTime, 4, 2)        elif pairing[key][2] == 5:            ReCheckTime(handle, timezone.now(), WaitTime, 5, 3)        elif pairing[key][2] == 6:            message = json.dumps({                "action": "checkfocussecond",                "userid": handle.userid})            WriteMessage(handle, message)    # 自身是GU 去确认DU是否已经关注自己    def HufenStateBack_9(self, handle,key):        pairing[key][1] = handle        message = json.dumps({            "action": "checkfocusfirst",            "userid": handle.userid})        WriteMessage(handle, message)    # 自身是DU 等待GU选择确认结果    def HufenStateBack_10(self, handle, key, UserState):        pairing[key][0] = handle        if pairing[key][2] == 3:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 3, 0)        elif pairing[key][2] == 4:            ReCheckTime(handle, timezone.now(), WaitTime, 4, 2)        elif pairing[key][2] == 5:            ReCheckTime(handle, timezone.now(), WaitTime, 5, 3)        elif pairing[key][2] == 6:            message = json.dumps({                "action": "checkfocussecond",                "userid": handle.userid})            WriteMessage(handle, message)    # 自身是GU 去选择确认结果    def HufenStateBack_11(self, handle, key):        pairing[key][1] = handle        message = json.dumps({"action": "doconfirmpre",                              "userid": handle.userid})        WriteMessage(handle, message)    # 自身是DU 等待GU选择是否去关注自己    def HufenStateBack_12(self,handle,key,UserState):        pairing[key][0] = handle        if pairing[key][2] == 4:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 4, 2)        elif pairing[key][2] == 5:            ReCheckTime(handle, timezone.now(), WaitTime, 5, 3)        elif pairing[key][2] == 6:            message = json.dumps({                "action": "checkfocussecond",                "userid": handle.userid})            WriteMessage(handle, message)    # 自身是GU 选择是否去关注DU    def HufenStateBack_13(self, handle, key):        pairing[key][1] = handle        message = json.dumps({            "action": "doconfirmsecond",            "userid": handle.pairuserid})        WriteMessage(handle, message)    # 自身是DU 等待GU选择是否已经关注自己    def HufenStateBack_14(self, handle, key, UserState):        pairing[key][0] = handle        if pairing[key][2] == 5:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 5, 3)        elif pairing[key][2] == 6:            message = json.dumps({                "action": "checkfocussecond",                "userid": handle.userid})            WriteMessage(handle, message)    # 自身是GU 选择是否已经关注DU    def HufenStateBack_15(self, handle, key):        pairing[key][1] = handle        message = json.dumps({"action": "dofocussecond"})        WriteMessage(handle, message)    # 自身是GU 等待DU去快手确认    def HufenStateBack_16(self, handle, key, UserState):        pairing[key][1] = handle        if pairing[key][2] == 6:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 6, 5)        elif pairing[key][2] == 7:            ReCheckTime(handle, timezone.now(), WaitTime, 7, 0)        elif pairing[key][2] == 8:            handle.user = User.objects.filter(userid=handle.userid).first()            pair_int = (handle.user.integral) - cost            message = json.dumps({                "action": "dopairsuccess",                "userid": handle.pairuserid,                "cost": int(cost),                "integral": pair_int})            WriteMessage(handle, message)            User.objects.filter(userid=handle.userid).update(integral=F('integral') - cost)            handle.HufenPos = 0            StateSave(handle, 0, 0)            HufenFail123(handle, 1, "NoErr")            print(handle.userid,"与" ,handle.pairuserid,"双方互粉成功，写入数据库")            # 成功互粉后删除会话            DelPairing(key)    # 自身是DU 去确认GU是否已经关注自己    def HufenStateBack_17(self, handle, key):        pairing[key][0] = handle        message = json.dumps({            "action": "checkfocussecond",            "userid": handle.userid})        WriteMessage(handle, message)    # 自身是GU 等到DU确认结果    def HufenStateBack_18(self, handle, key, UserState):        pairing[key][1] = handle        if pairing[key][2] == 7:            ReCheckTime(handle, UserState['StaTime'], UserState['OverTime'], 7, 0)        elif pairing[key][2] == 8:            handle.user = User.objects.filter(userid=handle.userid).first()            pair_int = (handle.user.integral) - cost            message = json.dumps({                "action": "dopairsuccess",                "userid": handle.pairuserid,                "cost": int(cost),                "integral": pair_int})            WriteMessage(handle, message)            User.objects.filter(userid=handle.userid).update(integral=F('integral') - cost)            handle.HufenPos = 0            StateSave(handle, 0, 0)            HufenFail123(handle, 1, "NoErr")            print(str(handle.userid) + "与" + str(handle.pairuserid) + "双方互粉成功，写入数据库")            # 成功互粉后删除会话            DelPairing(key)    # 自身是DU 选择确认结果    def HufenStateBack_19(self, handle, key):        pairing[key][0] = handle        message = json.dumps({"action": "doconfirmfin",                              "userid": handle.userid})        WriteMessage(handle, message)    def HufenStateBack_20(self, handle, key):        pairing[key][1] = handle        if pairing[key][2] == 8:            handle.user = User.objects.filter(userid=handle.userid).first()            pair_int = (handle.user.integral) - cost            message = json.dumps({                "action": "dopairsuccess",                "userid": handle.pairuserid,                "cost": int(cost),                "integral": pair_int})            WriteMessage(handle, message)            User.objects.filter(userid=handle.userid).update(integral=F('integral') - cost)            handle.HufenPos = 0            StateSave(handle, 0, 0)            HufenFail123(handle, 1, "NoErr")            print(handle.userid, "与" ,handle.pairuserid ,"双方互粉成功，写入数据库")            # 成功互粉后删除会话            DelPairing(key)    # 对方终止互粉    def HufenErrorBack_1(self, handle):        handle.HufenPos = 0        StateSave(handle, 0, 0)        message = json.dumps({            "action": "errorpair",            "state": "cancelpair"})        WriteMessage(handle, message)    # 重新发送对方的信息    def HufenErrorBack_2(self, handle,pairuser,UserState):        message = json.dumps({            "action": "pair",            "username": pairuser.username,            "userid": handle.pairuserid,            "photo": pairuser.total_photo,            "credit": pairuser.credit,            "totaltime": UserState['Pairtotaltime'],            "sucrate": UserState['Pairsucrate']})        WriteMessage(handle, message)        # 重连过程中对方掉线了...    # 对方终止互粉    def HufenErrorBack_3(self, handle):        handle.HufenPos = 0        StateSave(handle, 0, 0)        message = json.dumps({            "action": "errorpair",            "state": "cancelpair"})        WriteMessage(handle, message)    # 对方终止互粉 关注前    def HufenErrorBack_4(self, handle):        message = json.dumps({            "action": "errorpair",            "state": "ErrBeforeFocus"})        ReTipForError(handle, message)    # 对方终止互粉 关注后    def HufenErrorBack_5(self, handle):        message = json.dumps({            "action": "errorpair",            "state": "ErrAfterFocus",            "otherid": handle.pairuserid})        ReTipForError(handle, message)    def HufenErrorBack_6(self, handle):        handle.user = User.objects.filter(userid=handle.userid)        pair_int = (handle.user.integral) - cost        message = json.dumps({            "action": "dopairsuccess",            "userid": handle.pairuserid,            "cost": int(cost),            "integral": pair_int})        WriteMessage(handle, message)        User.objects.filter(userid=handle.userid).update(integral=F('integral') - cost)        handle.HufenPos = 0        StateSave(handle, 0, 0)        HufenFail123(handle, 1, "NoErr")        print(handle.userid,"与" ,handle.pairuserid ,"双方互粉成功，写入数据库")# 处理消息事物的类class EventHandle():    global hufenstate    global PairTime    global alive    State = StateBack()    def userinfo(self,handle,user):        handle.user = user        handle.pairuser = user        handle.addcredit = 0  # 要增加的权重        handle.userid = user.userid        handle.pairuserid = user.userid        handle.username = None        handle.headurl = None        handle.Pairtotaltime = 0  # 保存匹配方总互粉数        handle.Pairsucrate = 0.0  # 保存匹配方互粉成功率        handle.pairwait = 0  # 0-未匹配或超时,1-正在匹配        handle.timewait = 0  # 0-未计时或超时,1-正在计时        handle.HufenPos = 0  # 匹配进度 0-无操作 1-匹配中 2-互粉中        handle.totaltime = 0  # 自身匹配总次数        handle.sucrate = 0  # 自身互粉成功率        handle.statime = timezone.now()  # 初始化开始时间        handle.overtime = 0  # 超时持续时间        handle.weight = 0  # 初始匹配权重        handle.pairweight = 0  # 初始对方权重        handle.bepairweight = 0  # 被匹配权重        handle.IsDU = 0 # 是否为低用户    def erroruser(self,handle):        handle.userid = 0  # 保存自身用户ID        handle.pairuserid = 0  # 初始化匹配用户信息        handle.username = None        handle.headurl = None        handle.Pairtotaltime = 0  # 保存匹配方总互粉数        handle.Pairsucrate = 0.0  # 保存匹配方互粉成功率        handle.pairwait = 0  # 0-未匹配或超时,1-正在匹配        handle.timewait = 0  # 0-未计时或超时,1-正在计时        handle.HufenPos = 0  # 匹配进度 0-无操作 1-匹配中 2-互粉中        handle.totaltime = 0  # 自身匹配总次数        handle.sucrate = 0  # 自身互粉成功率        handle.statime = timezone.now()  # 初始化开始时间        handle.overtime = 0  # 超时持续时间        handle.weight = 0  # 初始匹配权重        handle.pairweight = 0  # 初始对方权重        handle.bepairweight = 0  # 被匹配权重        handle.IsDU = 0 # 是否为低用户        message = json.dumps({"error": "initerror"})        WriteMessage(handle,message)        StateSave(handle, 0, 0)    def stateback(self,handle,UserState):        handle.HufenPos = UserState['HufenPos']        handle.weight = UserState['Weight']        handle.pairweight = UserState['PairWeight']        handle.bepairweight = UserState['Beweight']        handle.IsDU = UserState['IsDU']        # 匹配中掉线        if UserState['HufenPos'] == 1:           self.State.PairStateBack(handle)           message = json.dumps({"action": "prepos"})           WriteMessage(handle, message)        # 互粉过程中掉线        elif UserState['HufenPos'] == 2:            kspairuser = User.objects.filter(userid=UserState['PairUserId']).first()            if kspairuser:                handle.pairuserid = kspairuser.userid                key = get_key(handle)                # 如果之前的会话还存在，则还原会话                if key in pairing:                    if UserState['PairingPos'] == -2:                        self.State.HufenStateBack_1(handle,kspairuser,UserState)                    # 会话中只有一个用户                    elif UserState['PairingPos'] == -1:                        if UserState['IsWait']:                            self.State.HufenStateBack_2(handle,key,UserState)                        else:                            self.State.HufenStateBack_3(handle,kspairuser,UserState)                    # 双方都点击确认互粉                    elif UserState['PairingPos'] == 0:                        if not UserState['IsDU']:                            self.State.HufenStateBack_4(handle,key,UserState)                        else:                            self.State.HufenStateBack_5(handle,key)                    # DU选择了去关注GU                    elif UserState['PairingPos'] == 1:                        if not UserState['IsDU']:                            self.State.HufenStateBack_6(handle,key,UserState)                        else:                            self.State.HufenStateBack_7(handle,key)                    # DU选择已经关注GU                    elif UserState['PairingPos'] == 2:                        if UserState['IsDU']:                            self.State.HufenStateBack_8(handle,key,UserState)                        else:                            self.State.HufenStateBack_9(handle,key)                    # GU 选择去确认DU是否已经关注自己                    elif UserState['PairingPos'] == 3:                        if UserState['IsDU']:                            self.State.HufenStateBack_10(handle,key,UserState)                        else:                            self.State.HufenStateBack_11(handle,key)                    # GU 选择DU已经关注                    elif UserState['PairingPos'] == 4:                        if UserState['IsDU']:                            self.State.HufenStateBack_12(handle,key,UserState)                        else:                            self.State.HufenStateBack_13(handle,key)                    # GU 选择去关注DU                    elif UserState['PairingPos'] == 5:                        if UserState['IsDU']:                            self.State.HufenStateBack_14(handle,key,UserState)                        else:                            self.State.HufenStateBack_15(handle,key)                    # GU 选择已经关注DU                    elif UserState['PairingPos'] == 6:                        if not UserState['IsDU']:                            self.State.HufenStateBack_16(handle,key,UserState)                        else:                            self.State.HufenStateBack_17(handle,key)                    # DU 选择去快手确认                    elif UserState['PairingPos'] == 7:                        if not UserState['IsDU']:                            self.State.HufenStateBack_18(handle,key,UserState)                        else:                            self.State.HufenStateBack_19(handle,key)                    # 互粉结束的时候掉线的情况很少见                    elif UserState['PairingPos'] == 8:                        if not UserState['IsDU']:                            self.State.HufenStateBack_20(handle,key)                # 以上是正常互粉过程恢复                # 以下是异常互粉过程恢复                # 要判断会话还没创建还是会话已结束                else:                    if UserState['PairingPos'] == -2:                        first = handle.userid                        second = handle.pairuserid                        if first > second:  # first 代表ID小的的用户                            first = handle.pairuserid                            second = handle.userid                            ID = str(first) + '_' + str(second)                            # 对方终止互粉                            if HufenHistory.objects.filter(HufenId=ID, state=4).exists():                                self.State.HufenErrorBack_1(handle)                                 # 之前匹配成功，还未创建会话                            elif HufenHistory.objects.exclude(HufenId=ID, state=4).exists():                                self.State.HufenErrorBack_2(handle,kspairuser,UserState)                            else:                                ServerError(handle, "数据库异常:")                    elif UserState['PairingPos'] == -1:                        if UserState['IsWait']:                            self.State.HufenErrorBack_3(handle)                        else:                            TipForOvertime(handle)                    elif UserState['PairingPos'] in [0, 1]:                        if not UserState['IsDU']:                            self.State.HufenErrorBack_4(handle)                        else:                            TipForOvertime(handle)                    elif UserState['PairingPos'] in [2, 3, 4, 5]:                        # 自身为DU 对方取消确认/关注                        if UserState['IsDU']:                            self.State.HufenErrorBack_5(handle)                        else:                            TipForOvertime(handle)                    elif UserState['PairingPos'] in [6, 7]:                        # 自身为GU 对方取消确认                        if not UserState['IsDU']:                            self.State.HufenErrorBack_5(handle)                        else:                            TipForOvertime(handle)                    elif UserState['PairingPos'] == 8:                        self.State.HufenErrorBack_6(handle)            else:                ServerError(handle,"用户ID:" + str(UserState['PairUserId']) + "不存在")        else:            message = json.dumps({"action": "prepos"})            WriteMessage(handle, message)    def message_HeartBeat(self,Msg):        handle = Msg[0]        message = json.dumps({"heart": "accept-heart"})        WriteMessage(handle, message)    def message_init(self,Msg):        handle = Msg[0]        msg = Msg[1]        try:            # if "sessionid" in msg:            #     sessionid = msg['sessionid']            #     user = session2user(sessionid)            #     uid = user.userid            # elif "uid" in msg:            #     uid = msg['uid']            #     user = User.objects.filter(userid=uid).first()            # else:            #     uid = 0            # print(uid)            sessionid = msg['sessionid']            user = session2user(sessionid)            if not user:                message = json.dumps({"error": "initerror"})                WriteMessage(handle, message)                return            else:                self.userinfo(handle,user)                CheckUserlist(user.userid) #判断该用户是否已登录                #获取前一次登陆状态                if handle.userid in hufenstate:                    UserState = hufenstate[handle.userid]                else:                    StateSave(handle, 0, 0)                    UserState = hufenstate[handle.userid]                if UserState:                    self.stateback(handle,UserState)                users_lock.acquire()                users[user.userid] = handle  # 保存当前用户句柄                users_lock.release()                print(user.username,"登录成功")        except:           self.erroruser(handle)    # 在无操作状态的用户点击开始互粉按钮    def message_pair(self,Msg):        handle = Msg[0]        if handle.HufenPos == 0:            DoPair(handle, timezone.now(), PairTime)        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:pair' + \              ' HufenPos:' + str(handle.HufenPos))    # 判断用户是否处于在线    def message_IsAlive(self,Msg):        handle = Msg[0]        if handle.HufenPos == 1:            key = get_key(handle)            if key in alive:                if handle not in alive[key]:                    alive[key].append(handle)                    StateSave(handle, 1, 1)                    # 取消判断是否在线的计时                    handle.timewait = 0                if len(alive[key]) == 2:                    # 刷新用户信息                    handle.user = User.objects.filter(userid=handle.userid).first()                    handle.pairuser = User.objects.filter(userid=handle.pairuserid).first()                    # 向匹配双方发送对方的信息                    message1 = json.dumps({                        "action": "pair",                        "username": handle.pairuser.username,                        "userid": handle.pairuserid,                        "photo": handle.pairuser.total_photo,                        "credit": handle.pairuser.credit,                        "totaltime": alive[key][0].totaltime,                        "sucrate": alive[key][0].sucrate})                    message2 = json.dumps({                        "action": "pair",                        "username": handle.user.username,                        "userid": handle.userid,                        "photo": handle.user.total_photo,                        "credit": handle.user.credit,                        "totaltime": handle.totaltime,                        "sucrate": handle.sucrate})                    WriteMessage(handle, message1)                    WriteMessage(alive[key][0], message2)                    alive[key][0].HufenPos = 2 # 进入互粉状态                    alive[key][1].HufenPos = 2  # 进入互粉状态                    print("匹配信息：user_" + alive[key][0].user.username + "匹配到 user_" + alive[key][1].user.username)                    StateSave(alive[key][0], -2, 1)                    hufenstate[alive[key][0].userid]['Pairtotaltime'] = alive[key][1].totaltime                    hufenstate[alive[key][0].userid]['Pairsucrate'] = alive[key][1].sucrate                    StateSave(alive[key][1], -2, 1)                    hufenstate[alive[key][1].userid]['Pairtotaltime'] = alive[key][1].totaltime                    hufenstate[alive[key][1].userid]['Pairsucrate'] = alive[key][1].sucrate        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:IsAlive' + \                  ' HufenPos:' + str(handle.HufenPos))    # 在互粉状态的用户点击确认互粉按钮    def message_dopair(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)  # 此时已经匹配了，pairuser已经更新            if key not in pairing:  # 保存确认互粉的会话,不存在则创建                pairing[key] = [handle]                # 先点击确认的用户计时                handle.statime = timezone.now()                handle.overtime = WaitTime                SetCheckTime(handle, 2, -1)  # 进入超时判断队列                StateSave(handle, -1, 1)                # 自身是先点确定的用户                hufenstate[handle.userid]['IsWait'] = 1                hufenstate[handle.userid]['StaTime'] = handle.statime                hufenstate[handle.userid]['OverTime'] = handle.overtime                if handle.weight < handle.pairweight:                    handle.IsDU = 1                    hufenstate[handle.userid]['IsDU'] = 1                else:                    handle.IsDU = 0                    hufenstate[handle.userid]['IsDU'] = 0            elif handle not in pairing[key]:  # 已存在则添加用户                pairing[key].append(handle)                StateSave(handle, -1, 1)                hufenstate[handle.userid]['Pairtotaltime'] = pairing[key][0].totaltime                hufenstate[handle.userid]['Pairsucrate'] = pairing[key][0].sucrate                # 自身为DU                if handle.weight <= handle.pairweight:                    handle.IsDU = 1                    hufenstate[handle.userid]['IsDU'] = 1                else:                    handle.IsDU = 0                    hufenstate[handle.userid]['IsDU'] = 0            if len(pairing[key]) == 2:  # 必须两个互粉用户都在                # 取消计时                if pairing[key][0].userid in checktime:                    pairing[key][0].timewait = 0                pairing[key].append(0)  # 记录会话状态，0-双方点击确认                # [DU,GU]                self1 = pairing[key][0]                self2 = pairing[key][1]                # 相同信誉值时，后点确认互粉的先关注，立马能关注                if self1.weight >= self2.weight:  # 信誉值低先关注  self1先                    self1 = pairing[key][1]                    self2 = pairing[key][0]                    # [DU,GU]                    pairing[key][0] = self1                    pairing[key][1] = self2                message1 = json.dumps({                    "action": "dopairfirst",                    "userid": self2.userid,                    "usetime": WaitTime})                message2 = json.dumps({                    "action": "dopairsecond",                    "userid": self1.userid,                    "state": "wait"})                if self1.userid in users:                    self1.ctime = timezone.now()                    WriteMessage(self1, message1)                if self2.userid in users:                    WriteMessage(self2, message2)                # GU计时                self2.statime = timezone.now()                self2.overtime = WaitTime                SetCheckTime(self2, 2, 0)  # 进入超时判断队列                hufenstate[self1.userid]['PairingPos'] = 0                hufenstate[self2.userid]['PairingPos'] = 0        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:dopair' + \                  ' HufenPos:' + str(handle.HufenPos))    # 重新匹配    def message_repair(self,Msg):        handle = Msg[0]        if handle.HufenPos == 0:            DoPair(handle, timezone.now(), PairTime)        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:repair' + \                  ' HufenPos:' + str(handle.HufenPos))    # 换个老铁 判断是否处于会话中 防止攻击    def message_change(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            # 有人点击了确认互粉            if key in pairing:                # 不处于互粉状态                if len(pairing[key]) != 3:                    TipForChange(handle)                else:                    ServerError(handle, "会话异常")            else:                TipForChange(handle)        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:change' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低信誉值用户选择去快手关注匹配用户    def message_ConfirmPairFirst(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    # 当前用户为DU                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            # 服务器状态为双方点击确认互粉                            if pairing[key][2] == 0:                                # 进入下一步会话状态                                pairing[key][2] = 1                                StateSave(handle, 1, 1)                                message = json.dumps({"action": "doconfirmfirst",                                                      "usetime":WaitTime})                                WriteMessage(handle, message)                                # 对方开始计时                                if handle.pairuserid in users:                                    users[handle.pairuserid].statime = timezone.now()                                    users[handle.pairuserid].overtime = WaitTime                                    SetCheckTime(users[handle.pairuserid], 2, 1)                            else:                                ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时不允许关注操作")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为0时不是对应会话中的低用户，不能先发起关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ConfirmPairFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低信誉值用户选择已经关注匹配用户    def message_ConfirmFocusFirst(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 1:                                pairing[key][2] = 2                                handle.statime = timezone.now()                                handle.overtime = WaitTime                                SetCheckTime(handle, 2, 2)                                StateSave(handle, 2, 1)                                hufenstate[handle.userid]['StaTime'] = handle.statime                                hufenstate[handle.userid]['OverTime'] = handle.overtime                                message = json.dumps({                                    "action": "checkfocusfirst",                                    "userid": handle.pairuserid,                                    "usetime":WaitTime})                                if handle.pairuserid in users:                                    # 取消对方的计时                                    if handle.pairuserid in checktime:                                        users[handle.pairuserid].timewait = 0                                    WriteMessage(users[handle.pairuserid], message)                            else:                                ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时不允许确认已关注操作")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为1时不是对应会话中的低用户，不能确认自己已关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ConfirmFocusFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高信誉值用户选择去快手确认对方是否关注    def message_CheckFocusFirst(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 2:                                pairing[key][2] = 3                                StateSave(handle, 3, 1)                                message1 = json.dumps({"action": "doconfirmpre",                                                       "userid":handle.userid,                                                       "usetime":WaitTime})                                message2 = json.dumps({                                    "action": "dofocusfirst",                                    "state": "makeconfirm"})                                WriteMessage(handle, message1)                                if handle.pairuserid in users:                                    WriteMessage(users[handle.pairuserid], message2)                                    # 刷新计时                                    users[handle.pairuserid].statime = timezone.now()                                    users[handle.pairuserid].overtime = WaitTime                                    SetCheckTime(users[handle.pairuserid], 2, 3)                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许确认对方是否关注")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为2时不是对应会话中的高用户，不能确认对方是否关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ConfirmFocusFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高信誉值用户选择重新去快手确认对方是否关注    def message_ReCheckFocusFirst(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 3:                                pairing[key][2] = 3                                StateSave(handle, 3, 1)                                message1 = json.dumps({"action": "doconfirmpre",                                                        "userid":handle.userid,                                                        "usetime":WaitTime})                                message2 = json.dumps({                                    "action": "dofocusfirst",                                    "state": "remakeconfirm"})                                WriteMessage(handle, message1)                                if handle.pairuserid in users:                                    WriteMessage(users[handle.pairuserid], message2)                                    # 刷新计时                                    users[handle.pairuserid].statime = timezone.now()                                    users[handle.pairuserid].overtime = WaitTime                                    SetCheckTime(users[handle.pairuserid], 2, 3)                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许确认对方是否关注")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为2时不是对应会话中的高用户，不能确认对方是否关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ReCheckFocusFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高信誉值用户选择对方已经关注自己    def message_ConfirmFocusPre(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 3:                                pairing[key][2] = 4                                StateSave(handle, 4, 1)                                message1 = json.dumps({                                    "action": "doconfirmsecond",                                    "userid": handle.pairuserid,                                    "usetime":WaitTime})                                message2 = json.dumps({                                    "action": "dofocusfirst",                                    "state": "makefocus"})                                WriteMessage(handle, message1)                                if handle.pairuserid in users:                                    WriteMessage(users[handle.pairuserid], message2)                                    # 刷新计时                                    users[handle.pairuserid].statime = timezone.now()                                    users[handle.pairuserid].overtime = WaitTime                                    SetCheckTime(users[handle.pairuserid], 2, 4)                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许确认对方已经关注")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为3时不是对应会话中的高用户，不能确认对方已经关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ConfirmFocusPre' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高信誉值用户选择去快手关注对方    def message_ConfirmFocusSecond(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 4:                                pairing[key][2] = 5                                StateSave(handle, 5, 1)                                message = json.dumps({"action": "dofocussecond",                                                      "usetime":WaitTime})                                message2 = json.dumps({                                    "action": "dofocusfirst",                                    "state": "dofocus"})                                WriteMessage(handle, message)                                if handle.pairuserid in users:                                    WriteMessage(users[handle.pairuserid], message2)                                    # 刷新计时                                    users[handle.pairuserid].statime = timezone.now()                                    users[handle.pairuserid].overtime = WaitTime                                    SetCheckTime(users[handle.pairuserid], 2, 5)                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许关注对方")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为4时不是对应会话中的高用户，不能去关注对方")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ConfirmFocusSecond' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高信誉值用户选择已经关注对方    def message_ConfirmSuccessFirst(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 5:                                pairing[key][2] = 6                                handle.statime = timezone.now()                                handle.overtime = WaitTime                                SetCheckTime(handle, 2, 6)                                StateSave(handle, 6, 1)                                hufenstate[handle.userid]['StaTime'] = handle.statime                                hufenstate[handle.userid]['OverTime'] = handle.overtime                                message = json.dumps({                                    "action": "checkfocussecond",                                    "userid": handle.pairuserid,                                    "usetime":WaitTime})                                if handle.pairuserid in users:                                    if handle.pairuserid in checktime:                                        users[handle.pairuserid].timewait = 0                                    WriteMessage(users[handle.pairuserid], message)                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许确认已经关注对方")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为5时不是对应会话中的高用户，不能确认已经关注对方")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ConfirmSuccessFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低信誉值用户选择去快手确认对方是否关注    def message_CheckFocusSecond(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 6:                                pairing[key][2] = 7                                StateSave(handle, 7, 1)                                message1 = json.dumps({"action": "doconfirmfin",                                                       "userid":handle.userid,                                                       "usetime":WaitTime})                                message2 = json.dumps({                                    "action": "dopairsecond",                                    "state": "makeconfirm"})                                WriteMessage(handle, message1)                                if handle.pairuserid in users:                                    WriteMessage(users[handle.pairuserid], message2)                                    # 刷新计时                                    users[handle.pairuserid].statime = timezone.now()                                    users[handle.pairuserid].overtime = WaitTime                                    SetCheckTime(users[handle.pairuserid], 2, 7)                            else:                                ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时不允许去确认对方是否关注")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为6时不是对应会话中的低用户，不能去确认对方是否关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:CheckFocusSecond' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低信誉值用户选择重新去快手确认对方是否关注    def message_ReCheckFocusSecond(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 7:                                pairing[key][2] = 7                                StateSave(handle, 7, 1)                                message1 = json.dumps({"action": "doconfirmfin",                                                       "userid":handle.userid,                                                       "usetime":WaitTime})                                message2 = json.dumps({                                    "action": "dopairsecond",                                    "state": "remakeconfirm"})                                WriteMessage(handle, message1)                                if handle.pairuserid in users:                                    WriteMessage(users[handle.pairuserid], message2)                                    # 刷新计时                                    users[handle.pairuserid].statime = timezone.now()                                    users[handle.pairuserid].overtime = WaitTime                                    SetCheckTime(users[handle.pairuserid], 2, 7)                            else:                                ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时不允许去确认对方是否关注")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为6时不是对应会话中的低用户，不能去确认对方是否关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ReCheckFocusSecond' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低信誉值用户选择对方已经关注自己,匹配成功    def message_ConfirmSuccessSecond(self,Msg):        handle = Msg[0]        global success        global suc_lock        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 7:                                pairing[key][2] = 8                                StateSave(handle, 8, 1)                                # 匹配时就已经创建了state为0的记录                                HufenFail123(handle, 1, "NoErr")                                suc_lock.acquire()                                success += 1                                suc_lock.release()                                print(str(handle.userid) + "与" + str(handle.pairuserid) + "双方互粉成功，写入数据库",success)                                handle.user = User.objects.filter(userid=handle.userid).first()                                handle.pairuser = User.objects.filter(userid=handle.pairuserid).first()                                self_int = (handle.user.integral) - cost                                pair_int = (handle.pairuser.integral) - cost                                message1 = json.dumps({                                    "action": "dopairsuccess",                                    "userid": handle.pairuserid,                                    "cost": int(cost),                                    "integral": self_int})                                message2 = json.dumps({                                    "action": "dopairsuccess",                                    "userid": handle.userid,                                    "cost": int(cost),                                    "integral": pair_int})                                User.objects.filter(userid=handle.userid).update(integral=F('integral') - cost)                                # 重置用户状态                                handle.HufenPos = 0                                StateSave(handle,0,0)                                WriteMessage(handle, message1)                                if handle.pairuserid in users:                                    User.objects.filter(userid=handle.pairuserid).update(integral=F('integral') - cost)                                    users[handle.pairuserid].HufenPos = 0                                    StateSave(users[handle.pairuserid],0,0)                                    # 成功互粉后删除会话                                    DelPairing(key)                                    WriteMessage(users[handle.pairuserid], message2)                            else:                                ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时不允许确认对方已经关注")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为7时不是对应会话中的低用户，不能去确认对方是否关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:ConfirmSuccessSecond' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低用户取消/否定去关注匹配用户    def message_NoConfirmPairFirst(self,Msg):        handle = Msg[0]        msg = Msg[1]        if handle.HufenPos == 2:            cmd = msg            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 0:                                if "state" in cmd:                                    if cmd["state"] == "cancel":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorDU_1_1"})                                        # 互粉终止的记录与通知                                        TipForError(handle, key, message)                                    elif cmd["state"] == "deny":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorDU_1_2"})                                        TipForError(handle, key, message)                                    else:                                        ServerError(handle,                                                    "DU在会话状态为：" + str(pairing[key][2]) + "时取消去关注发送的数据中state字段键值不存在")                                else:                                    ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时取消去关注发送的数据没有state字段")                            else:                                ServerError(handle, "会话异常")                        else:                            ServerError(handle, "DU在会话状态不为0时不允许取消/否定去关注对方")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为0时不是对应会话中的低用户，不能取消/否定去关注对方")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoConfirmPairFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低用户取消/否定已经关注匹配用户    def message_NoConfirmFocusFirst(self,Msg):        handle = Msg[0]        msg = Msg[1]        if handle.HufenPos == 2:            cmd = msg            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 1:                                if "state" in cmd:                                    if cmd["state"] == "cancel":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorDU_2_1"})                                        # 互粉终止的记录与通知                                        TipForError(handle, key, message)                                    elif cmd["state"] == "deny":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorDU_2_2"})                                        TipForError(handle, key, message)                                    else:                                        ServerError(handle,                                                    "DU在会话状态为：" + str(pairing[key][2]) + "时取消已经关注发送的数据中state字段键值不存在")                                else:                                    ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时取消已经关注发送的数据没有state字段")                            else:                                ServerError(handle, "会话异常")                        else:                            ServerError(handle, "DU在会话状态不为1时不允许取消/否定已经关注对方")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为1时不是对应会话中的低用户，不能取消/否定已经关注对方")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoConfirmFocusFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高用户取消去快手确认对方是否关注    def message_NoCheckFocusFirst(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 2:                                message = json.dumps({                                    "action": "errorpair",                                    "state": "ErrorGU_0",                                    "otherid": handle.userid})                                # 互粉终止的记录与通知                                TipForError(handle, key, message)                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许取消去确认是否被关注")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为2时不是对应会话中的高用户，不能取消去确认是否被关注")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoCheckFocusFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高用户取消/否定对方已经关注自己    def message_NoConfirmFocusPre(self,Msg):        handle = Msg[0]        msg = Msg[1]        if handle.HufenPos == 2:            cmd = msg            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 3:                                if "state" in cmd:                                    if cmd["state"] == "cancel":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorGU_1_1",                                            "otherid": handle.userid})                                        # 互粉终止的记录与通知                                        TipForError(handle, key, message)                                    elif cmd["state"] == "deny":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorGU_1_2",                                            "otherid": handle.userid})                                        TipForError(handle, key, message)                                    else:                                        ServerError(handle, "GU在会话状态为：" + str(                                            pairing[key][2]) + "时取消/否定对方关注自己发送的数据中state字段键值不存在")                                else:                                    ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时取消/否定对方关注自己发送的数据没有state字段")                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许取消/否定对方关注自己")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为3时不是对应会话中的高用户，不能取消/否定对方关注自己")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoConfirmFocusPre' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高用户取消/否定去快手关注对方    def message_NoConfirmFocusSecond(self,Msg):        handle = Msg[0]        msg = Msg[1]        if handle.HufenPos == 2:            cmd = msg            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 4:                                if "state" in cmd:                                    if cmd["state"] == "cancel":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorGU_2_1",                                            "otherid": handle.userid})                                        # 互粉终止的记录与通知                                        TipForError(handle, key, message)                                    elif cmd["state"] == "deny":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorGU_2_2",                                            "otherid": handle.userid})                                        TipForError(handle, key, message)                                    else:                                        ServerError(handle, "GU在会话状态为：" + str(                                            pairing[key][2]) + "时取消/否定去关注对方发送的数据中state字段键值不存在")                                else:                                    ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时取消/否定去关注对方发送的数据没有state字段")                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许取消/否定去关注对方")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为4时不是对应会话中的高用户，不能取消/否定去关注对方")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoConfirmFocusSecond' + \                  ' HufenPos:' + str(handle.HufenPos))    # 高用户取消/否定已经关注对方    def message_NoConfirmSuccessFirst(self,Msg):        handle = Msg[0]        msg = Msg[1]        if handle.HufenPos == 2:            cmd = msg            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 1:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 5:                                if "state" in cmd:                                    if cmd["state"] == "cancel":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorGU_3_1",                                            "otherid": handle.userid})                                        # 互粉终止的记录与通知                                        TipForError(handle, key, message)                                    elif cmd["state"] == "deny":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorGU_3_2",                                            "otherid": handle.userid})                                        TipForError(handle, key, message)                                    else:                                        ServerError(handle, "GU在会话状态为：" + str(                                            pairing[key][2]) + "时取消/否定已关注对方发送的数据中state字段键值不存在")                                else:                                    ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时取消/否定已关注对方发送的数据没有state字段")                            else:                                ServerError(handle, "GU在会话状态为：" + str(pairing[key][2]) + "时不允许取消/否定已关注对方")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为5时不是对应会话中的高用户，不能取消/否定已关注对方")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoConfirmSuccessFirst' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低用户取消去快手确认对方是否关注    def message_NoCheckFocusSecond(self,Msg):        handle = Msg[0]        if handle.HufenPos == 2:            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 6:                                message = json.dumps({                                    "action": "errorpair",                                    "state": "ErrorDU_0",                                    "otherid": handle.userid})                                TipForError(handle, key, message)                            else:                                ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时不允许取消去确认对方关注自己")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为6时不是对应会话中的低用户，不能取消去确认对方关注自己")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoCheckFocusSecond' + \                  ' HufenPos:' + str(handle.HufenPos))    # 低用户取消/否定选择对方已经关注自己    def message_NoConfirmSuccessSecond(self,Msg):        handle = Msg[0]        msg = Msg[1]        if handle.HufenPos == 2:            cmd = msg            key = get_key(handle)            if key in pairing:                if handle in pairing[key]:                    if pairing[key].index(handle) == 0:                        if len(pairing[key]) == 3:                            if pairing[key][2] == 7:                                if "state" in cmd:                                    if cmd["state"] == "cancel":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorDU_3_1",                                            "otherid": handle.userid})                                        # 互粉终止的记录与通知                                        TipForError(handle, key, message)                                    elif cmd["state"] == "deny":                                        message = json.dumps({                                            "action": "errorpair",                                            "state": "ErrorDU_3_2",                                            "otherid": handle.userid})                                        TipForError(handle, key, message)                                    else:                                        ServerError(handle, "DU在会话状态为：" + str(                                            pairing[key][2]) + "时取消/否定对方关注自己发送的数据中state字段键值不存在")                                else:                                    ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时取消/否定对方关注自己发送的数据没有state字段")                            else:                                ServerError(handle, "DU在会话状态为：" + str(pairing[key][2]) + "时不允许取消/否定对方关注自己")                        else:                            ServerError(handle, "会话异常")                    else:                        ServerError(handle, handle.user.username + "在会话状态不为7时不是对应会话中的低用户，不能取消/否定对方关注自己")            else:                ServerError(handle, "不存在包含用户：" + handle.user.username + "的会话")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:NoConfirmSuccessSecond' + \                  ' HufenPos:' + str(handle.HufenPos))    # 确认互粉之前关闭了弹窗    def message_CancelPairSecond(self,Msg):        handle = Msg[0]        msg = Msg[1]        if handle.HufenPos == 2:            message = json.dumps({                "action": "errorpair",                "state": "cancelpair"})            key = get_key(handle)            # 有人点击了确认互粉            if key in pairing:                # 不处于互粉状态                if len(pairing[key]) != 3:                    handle.HufenPos = 0                    StateSave(handle,0,0)                    HufenFail045(handle, 4, handle.user)                    DelPairing(key)                    if handle.pairuserid in users:                        users[handle.pairuserid].HufenPos = 0                        StateSave(users[handle.pairuserid],0,0)                        WriteMessage(users[handle.pairuserid], message)                    else:                        print("用户：" + handle.user.username + "不在用户表中")                else:                    ServerError(handle, "当前会话状态为：" + str(pairing[key][2]) + "时，确认互粉前关闭弹窗的操作无效")            # 没人点击确认互粉            else:                handle.HufenPos = 0                StateSave(handle, 0, 0)                HufenFail045(handle, 4, handle.user)                if handle.pairuserid in users:                    users[handle.pairuserid].HufenPos = 0                    StateSave(users[handle.pairuserid], 0, 0)                    WriteMessage(users[handle.pairuserid], message)                else:                    print("用户：" + handle.user.username + "不在用户表中")        else:            print(handle, "异常操作:User:" + str(handle.userid) + ' Action:CancelPairSecond' + \                  ' HufenPos:' + str(handle.HufenPos))# 待匹配队列处理线程class HufenPair(threading.Thread):    lis = []    lisbe = []    flag = 0    def __init__(self):        threading.Thread.__init__(self)    def run(self):        self.HufenPairThread()    # 按权值排序    def SortPairs(self):        global pairs        global pairs_lock        self.lis.clear()        self.lisbe.clear()        if pairs_lock.acquire():            ldo = sorted(pairs.items(), key=lambda d: d[1][1], reverse=True)            lbe = sorted(pairs.items(), key=lambda d: d[1][2], reverse=True)            # 释放锁            pairs_lock.release()        # 按照匹配权值排序的用户ID        for user in ldo:            self.lis.append(user[0])        for user in lbe:            self.lisbe.append(user[0])    # 处理匹配超时    def DealTimeOut(self):        global pairs        global pairs_lock        NoPair = json.dumps({"error": "nopair"})        for user in self.lis:            if user in pairs:                if pairs[user][0].pairwait == 0:                    print(user, "匹配超时")                    pairs[user][0].HufenPos = 0  # 无操作状态                    StateSave(pairs[user][0], 0, 0)                    WriteMessage(pairs[user][0], NoPair)                    self.lis.remove(user)                    self.lisbe.remove(user)                    if pairs_lock.acquire():                        del pairs[user]                        pairs_lock.release()            else:                print("user:" + str(user) + "not in pairs")    # 判断两用户是否匹配    def CheckMatch(self,handle1,handle2,ID):        # handle1 选择用户句柄        # handle2 被选择用户句柄        if not HufenHistory.objects.filter(HufenId=ID).exists():            return 1        else:            return 0    # 保存匹配双方状态和信息    def SavePairState(self,handle1,handle2,ID):        first = handle1.user        second = handle2.user        if handle1.userid > handle2.userid:            first = handle2.user            second = handle1.user        HufenHistory.objects.create(HufenId=ID, user1=first, user2=second, state=0, bguser=first)        handle1.pairuserid = handle2.userid  # 暂时保存待匹配的对方信息        handle1.pairuser = User.objects.filter(userid=handle2.userid).first()        handle1.pairweight = handle2.weight  # 保存对方权重        handle1.bepairweight = 0  # 匹配成功则清零被匹配权重        handle2.pairuserid = handle1.userid  # 暂时保存待匹配的对方信息        handle2.pairuser = User.objects.filter(userid=handle1.userid).first()        handle2.pairweight = handle1.weight  # 保存对方权重        handle2.bepairweight = 0    # 发送检测是否在线消息并计时    def CheckAliveMsg(self,handle1,handle2):        message = json.dumps({"action": "CheckAlive"})        WriteMessage(handle1, message)        WriteMessage(handle2, message)        key = get_key(handle1)        # 初始两用户都不在线        alive[key] = []        # 双方开始计时        handle1.statime = timezone.now()        handle1.overtime = LiveCheckTime        handle2.statime = timezone.now()        handle2.overtime = LiveCheckTime        # 双方开始计时判断是否在线        SetCheckTime(handle1, 3, 0)        SetCheckTime(handle2, 3, 0)    # 成功匹配之后的处理，保存状态与从匹配列表删除用户    def CompleteMatch(self,handle1,handle2):        global pairs        global pairs_lock        # 匹配中0-未确认是否在线        StateSave(handle1, 0, 1)        StateSave(handle2, 0, 1)        if pairs_lock.acquire():            del pairs[handle1.userid]            del pairs[handle2.userid]            pairs_lock.release()        self.flag = 1        self.lis.remove(handle1.userid)        self.lis.remove(handle2.userid)        self.lisbe.remove(handle2.userid)    def HufenPairThread(self):        global pairs        while True:            self.SortPairs()            self.DealTimeOut()            while len(self.lis) >= 2:                #删除正在选择的人                self.lisbe.remove(self.lis[0])                #没有匹配到过                self.flag = 0                for i in range(0,len(self.lisbe)):                    self1 = pairs[self.lis[0]][0]                    self2 = pairs[self.lisbe[i]][0]                    ID = str(self1.userid) + '_' + str(self2.userid)                    if self.lis[0] > self.lisbe[i]:  # first 代表ID小的的用户                        ID = str(self2.userid) + '_' + str(self1.userid)                    if self.CheckMatch(self1,self2,ID):                        self.SavePairState(self1,self2,ID)                        self.CheckAliveMsg(self1,self2)                        self.CompleteMatch(self1,self2)                        break                    else:                        print(pairs[self.lis[0]][0].user.username ,pairs[self.lisbe[i]][0].user.username,"不相匹配")                # 本次匹配未中 不剔除总匹配队                if not self.flag:                    pairs[self.lis[0]][0].bepairweight += 1                    del self.lis[0]            time.sleep(0.1)# 计时队列处理线程class CheckTime(threading.Thread):    lis = []    def __init__(self):        threading.Thread.__init__(self)    def run(self):        self.CheckTimeThread()    # 清除未计时用户与超时用户    def DealTimeOut(self):        global checktime        global checktime_lock        if checktime_lock.acquire():            self.lis = list(checktime.keys())            checktime_lock.release()        for user in self.lis:            if user in checktime:                if checktime[user][0].timewait == 0:                    self.lis.remove(user)                    if checktime_lock.acquire():                        del checktime[user]                        checktime_lock.release()            else:                print("user:" + str(user) + "not in checktime")    # 处理超时情况    def IfTimeOut(self,key):        global checktime        global pairing        global alive        # 正在匹配中        handle = checktime[key][0]        UserPos = checktime[key][1]        PrePos = checktime[key][2]        pairkey = get_key(handle)        if UserPos == 1:            if handle.HufenPos == PrePos:                self.PairTimeOut(handle)        # 在互粉过程中        elif UserPos == 2:            if pairkey in pairing:                if PrePos == -1 and len(pairing[pairkey]) != 3:                    self.HufenTimeOut(handle,pairkey)                elif PrePos != -1:                    if pairing[pairkey][2] == PrePos:                        self.HufenTimeOut(handle,pairkey)                handle.timewait = 0        # 确定是否在线        elif UserPos == 3:            if pairkey in alive:                # 没有用户在线                if len(alive[pairkey]) == 0:                    self.CheckLiveTimeOut1(handle)                elif len(alive[pairkey]) == 1:                    if handle in alive[pairkey]:                        self.CheckLiveTimeOut2(handle)                handle.timewait = 0    # 匹配超时    def PairTimeOut(self,handle):        handle.pairwait = 0        handle.timewait = 0    # 互粉超时：自身确认互粉，等待对方确认超时    def HufenTimeOut(self,handle,pairkey):        global users        workovertime = json.dumps({"action": "errorpair",                                   "state": "workovertime",                                   "otherid": handle.userid})        waitovertime = json.dumps({"action": "errorpair",                                   "state": "waitovertime",                                   "otherid": handle.pairuserid})        handle.HufenPos = 0  # 无操作状态        StateSave(handle, 0, 0)        WriteMessage(handle, waitovertime)        if handle.pairuserid in users:            handle2 = users[handle.pairuserid]            handle2.HufenPos = 0            StateSave(handle2, 0, 0)            WriteMessage(handle2, workovertime)        else:            print(handle.pairuserid,"不在用户列表中")        HufenFail045(handle, 0, handle.pairuser)        print("等待超时导致互粉失败")        DelPairing(pairkey)    def CheckLiveTimeOut1(self,handle):        global users        handle.HufenPos = 0  # 无操作状态        StateSave(handle, 0, 0)        print("用户：" ,handle.userid,"判断是否在线超时")        if handle.pairuserid in users:            handle2 = users[handle.pairuserid]            handle2.HufenPos = 0            StateSave(handle2, 0, 0)        else:            print(handle.userid, "不在用户列表中")    def CheckLiveTimeOut2(self,handle):        global addweight        global PairTime        handle.addcredit = handle.addcredit + addweight        DoPair(handle, timezone.now(), PairTime)        print("用户：",handle.userid, "判断是否在线超时,重新匹配")    def CheckTimeThread(self):        global checktime        while True:            self.DealTimeOut()            for key in self.lis:                endtime = timezone.now()                overtime = endtime - checktime[key][0].statime                if overtime.total_seconds() >= checktime[key][0].overtime:                    # 此处只处理超时情况，正常情况其他部分处理                    self.IfTimeOut(key)            time.sleep(1)# 互粉主逻辑class HufenHandler(tornado.websocket.WebSocketHandler):    executor = ThreadPoolExecutor(500)    global checktime    global hufenstate    global pairs    global alive    global alive_lock    global users    global users_lock    Event = EventHandle()    def check_origin(self, origin):        return True    def open(self):        self.state_alive = True        pass    @run_on_executor    def on_message(self, message):        message = json.loads(message)        # if message["action"] != "HeartBeat":        #     print(message)        Msg = [self,message]        try:            getattr(self.Event, "message_%s" % message["action"])(Msg)        except Exception as e:            print(e)    def on_close(self):        self.state_alive = False        if hasattr(self,"userid"):            if self.userid in users:                users_lock.acquire()                del users[self.userid]                users_lock.release()                print(self.user.username + "退出互粉大厅")                # 没有状态记录则保存状态                # StateSave(self, 0, 0)            # 未匹配到用户 还在匹配中            if self.userid in pairs:                pairs[self.userid][0].pairwait = 0                print(self.user.username + "退出匹配序列")            # 匹配到用户            # 正在互粉时断开连接，暂时保存会话列表，等待超时再删除            if self.HufenPos == 2:                key = get_key(self)                # 两个用户都还没点击确定互粉                if key in pairing:                    print(self.user.username + "退出正在匹配序列")            # 取消计时            if self.userid in checktime:                self.timewait = 0class Application(tornado.web.Application):    def __init__(self):        handlers = [            (r"/ws",HufenHandler),        ]        settings = {            'debug': True        }        tornado.web.Application.__init__(self, handlers,**settings)if __name__ == '__main__':    ws_app = Application()    server = tornado.httpserver.HTTPServer(ws_app)    server.listen(8081)    thread_pair = HufenPair()    thread_check = CheckTime()    thread_pair.start()    thread_check.start()    tornado.ioloop.IOLoop.instance().start()# for i in range(0, 10):#     User.objects.create(userid=i, username=str(i), credit=100, integral=200)# print("creat down")# ID = "3_2"# first = 3# second = 2# sta = 1# info = "error"# uptime = timezone.now()# HufenHistory.objects.create(HufenId=ID, user1=first, user2=second, state=0, bguser=first)# HufenHistory.objects.filter(HufenId=ID).update(user1=first,user2=second,state=sta,errinfo=info,hftime=uptime)